<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Matching App</title>
    <style>
        .hidden {
            display: none;
        }

        .highlight {
            background-color: red;
        }

        .matches {
            font-weight: bold;
        }

        .results {
            margin-top: 20px;
        }

        .state-input {
            width: 30px;
            margin: 5px;
            text-align: center;
        }

        .state-row {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <h1>State Matching App</h1>

    <h3>Enter the current states (1, X, 2) for each of the 13 fields:</h3>
    <div id="input-fields">
        <!-- 13 Input Fields will be rendered here -->
    </div>

    <br><br>

    <h3>Upload Active Combinations CSV:</h3>
    <input type="file" id="file-input" accept=".csv">

    <div class="results hidden" id="results">
        <h3>Matching Results:</h3>
        <div id="matches-list"></div>
    </div>

    <script>
        // Initialize an empty array for active combinations
        let activeCombinations = [];

        // Function to normalize the input states to handle case insensitivity and wildcard matching
        function normalizeState(state) {
            return state.trim().toUpperCase(); // Case-insensitive normalization
        }

        // Handle the file input and load the CSV data
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const csvContent = event.target.result;
                parseCSV(csvContent);
            };
            reader.readAsText(file);
        });

        // Parse the CSV content and populate the activeCombinations array
        function parseCSV(csvContent) {
            activeCombinations = [];
            const rows = csvContent.split("\n");
            rows.forEach(row => {
                const rowData = row.split(";");
                if (rowData.length === 13) {
                    activeCombinations.push(rowData);
                }
            });
            generateInputFields();
        }

        // Function to generate the input fields for the 13 states
        function generateInputFields() {
            const inputContainer = document.getElementById('input-fields');
            inputContainer.innerHTML = ''; // Clear any existing input fields

            for (let i = 0; i < 13; i++) {
                const inputField = document.createElement('input');
                inputField.type = 'text';
                inputField.classList.add('state-input');
                inputField.maxLength = 1; // Only one character per input
                inputField.dataset.index = i; // To track which field it corresponds to
                inputField.addEventListener('input', handleInputChange); // Update on input change
                inputContainer.appendChild(inputField);
            }

            // Display results container when the user inputs a value
            document.getElementById('results').classList.remove('hidden');
        }

        // Handle input change and trigger the matching function
        function handleInputChange() {
            const inputs = Array.from(document.querySelectorAll('.state-input'));
            const inputStates = inputs.map(input => normalizeState(input.value));

            // Perform matching when any input field changes
            const filteredCombinations = activeCombinations.filter(combination => {
                let matchCount = 0;
                let valid = true;

                for (let i = 0; i < 13; i++) {
                    const inputState = inputStates[i];
                    const combinationState = normalizeState(combination[i]);

                    // If inputState is empty, it's a wildcard and matches any value
                    if (inputState === '') {
                        matchCount++;
                    } else if (inputState === combinationState) {
                        matchCount++;
                    } else {
                        valid = false;
                        break;
                    }
                }

                return valid && matchCount >= 10; // Only keep rows with at least 10 matches
            });

            displayResults(filteredCombinations, inputStates);
        }

        // Display the matching results below the input fields
        function displayResults(filteredCombinations, inputStates) {
            const matchesList = document.getElementById('matches-list');
            matchesList.innerHTML = ''; // Clear previous results

            filteredCombinations.forEach(combination => {
                const matchRow = document.createElement('div');
                matchRow.classList.add('state-row');
                combination.forEach((state, index) => {
                    const stateDiv = document.createElement('div');
                    const inputState = inputStates[index];

                    if (inputState !== '' && normalizeState(state) !== inputState) {
                        stateDiv.classList.add('highlight');
                    }

                    stateDiv.textContent = state;
                    matchRow.appendChild(stateDiv);
                });

                matchesList.appendChild(matchRow);
            });
        }
    </script>
</body>
</html>
